A Common Lisp jq replacement
============================

Published on 2025-03-06

Tags: [lisp](/blog/tags/lisp.html), [programming](/blog/tags/programming.html)

* * *

Title says it all, I seriously dislike [`jq`](https://jqlang.org/)'s convoluted, impossible-to-remember _ad hoc_ DSL that instantly joined heaps of misery like CMake and gnuplot in my heart. It should really have been a library with a CLI wrapper around `eval` in a well-known scripting language like Python.

And I'm not the only one I've heard complain about this, yet it's the one that seized the mindshare and thus became easy to find in any package repository (sometimes even preinstalled) and with the most copy-paste fodder on the web. It won for the usual reasons: lack of serious competition at the time, enough flexibility to manage most tasks with enough pain and elbow grease and now inertia.

But me, I've reached my enough is enough! point and decided to do like [VapourSynth](https://www.vapoursynth.com/about/) or [waf](https://waf.io/) and replace it with a language I know and love: CL.

For now, [`cljq`](https://git.sr.ht/~q3cpma/cl-json-utils) is only a very bare-bones pipeline that parses a JSON (argv or stdin) into a variable `$`, [`eval`](https://www.lispworks.com/documentation/HyperSpec/Body/f_eval.htm#eval) an arbitrary CL form and serializes the result to stdout (using [jzon](https://github.com/Zulu-Inuoe/jzon)). But the query operator `?` inspired by [JSONPath](https://datatracker.ietf.org/doc/html/rfc9535#name-jsonpath-examples) is already an improvement, in my eyes:

$ json='{"root": {"a": \[0, 1\], "b": \[2, 3\]}}'
$ echo "$json" | jq '.root | map(.\[1\])'
\[
  1,
  3
\]
$ echo "$json" | cljq '(? $ "root" \* 1)'
\[
  1,
  3
\]

Here's a small JSONPath <=> `?` correspondance table (using some examples found in the aforementioned RFC):

JSONPath

cljq's `?`

`$.store.book[*].author`

`(? $ "store" "book" * "author")`

`$..author`

`(? $ ** "author")`

`$.store.*`

`(? $ "store" *)`

`$.store..price`

`(? $ "store" ** "price")`

`$..book[-1]`

`(? $ ** "book" -1)`

`$..book[0,1]`

`(? $ ** "book" (or 0 1))`

`$..book[0:2]`

`(? $ ** "book" (subseq 0 2))`

That's it for now; the README has a TODO section, if you want an idea of what's coming.

Anyone else rocking homegrown tools to fight the proliferation of crappy DSLs? Write an article about it and send me an email, I'll link it!

Made with [![Emacs](/resources/logos/emacs.svg)](https://www.gnu.org/software/emacs/), [![LISP](/resources/logos/lisp.svg)](https://common-lisp.net/) and [spinneret](https://github.com/ruricolist/spinneret), served by [![Caddy](/resources/logos/caddy.svg)](https://github.com/caddyserver/caddy) Generated by [make-website](https://git.sr.ht/~q3cpma/make-website) Fri, 02 May 2025 10:32:43 +0000
